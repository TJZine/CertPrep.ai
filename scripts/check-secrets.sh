#!/bin/bash

# Exit immediately if a command exits with a non-zero status
set -e

# 1. Check for .env files being committed
STAGED_ENV_FILES=$(git diff --cached --name-only | grep "\.env" | grep -v "\.env\.example" || true)

if [ -n "$STAGED_ENV_FILES" ]; then
  echo "❌ SECURITY ERROR: Attempting to commit .env files:"
  echo "$STAGED_ENV_FILES"
  echo "Please remove them from git (git rm --cached <file>) and add to .gitignore."
  exit 1
fi

# 2. Check for E2E auth files being committed (MUST run before early exit)
# These contain session tokens and should never be committed
# Only check for additions (A) or modifications (M), not deletions (D)
E2E_AUTH_FILES=$(git diff --cached --name-status | grep -E "^[AM]\s+tests/e2e/\.auth/(user\.json|user-id\.json)" | awk '{print $2}' || true)

if [ -n "$E2E_AUTH_FILES" ]; then
  echo "❌ SECURITY ERROR: Attempting to commit E2E auth files:"
  echo "$E2E_AUTH_FILES"
  echo ""
  echo "These files contain session tokens and should not be committed."
  echo "They are auto-generated by 'npx playwright test' via globalSetup."
  echo ""
  echo "To fix: git rm --cached tests/e2e/.auth/user.json tests/e2e/.auth/user-id.json"
  exit 1
fi

# 3. Check for accidental NEXT_PUBLIC_IS_E2E=true in production configs (MUST run before early exit)
ALL_STAGED=$(git diff --cached --name-only || true)
PROD_CONFIGS=$(echo "$ALL_STAGED" | grep -E "(\.env\.production|vercel\.json|netlify\.toml)" || true)

if [ -n "$PROD_CONFIGS" ]; then
  for CONFIG in $PROD_CONFIGS; do
    if [ -f "$CONFIG" ] && git show :"$CONFIG" 2>/dev/null | grep -q "NEXT_PUBLIC_IS_E2E.*true"; then
      echo "❌ SECURITY ERROR: NEXT_PUBLIC_IS_E2E=true found in production config:"
      echo "$CONFIG"
      echo ""
      echo "This flag should ONLY be set in development/test environments."
      echo "It exposes internal database state to window.__certprepDb."
      exit 1
    fi
  done
fi

# 4. Check for potential hardcoded secrets in staged files
# We exclude package-lock.json, this script itself, and the tests directory
STAGED_FILES=$(git diff --cached --name-only | grep -v "package-lock.json" | grep -v "scripts/check-secrets.sh" | grep -v "^tests/" || true)

if [ -z "$STAGED_FILES" ]; then
  echo "✅ Security check passed."
  exit 0
fi

# Define patterns to catch
# - Private Keys
# - AWS Keys
# - Generic API Keys (simple heuristics)
# - Database Connection Strings
# More specific patterns with context to reduce false positives
PATTERNS="-----BEGIN.*PRIVATE KEY-----|aws_access_key_id\s*=|ghp_[a-zA-Z0-9]{20,}|sk_live_[a-zA-Z0-9]{20,}|sk_test_[a-zA-Z0-9]{20,}|xox[baprs]-[a-zA-Z0-9-]{10,}|PRIVATE_KEY\s*=\s*['\"][^'\"]+|password\s*=\s*['\"][^'\"]+|Authorization:\s*Bearer [a-zA-Z0-9\-\._\~\+\/]+=*|postgres://[^:]+:[^@]+@|SG\.[a-zA-Z0-9_-]{20,}"

FOUND_SECRETS=0

for FILE in $STAGED_FILES; do
  # Skip deleted files
  if [ ! -f "$FILE" ]; then continue; fi

  # Search for patterns in the staged content using git show
  if git show :"$FILE" | grep -Eq -e "$PATTERNS"; then
    echo "❌ SECURITY WARNING: Potential secret found in $FILE"
    
    # Extract line numbers of all matches (don't print content to avoid leaking secrets)
    LINE_NUMS=$(git show :"$FILE" | grep -n -E -e "$PATTERNS" | cut -d: -f1 | tr '\n' ', ' | sed 's/,$//')
    
    echo "   → Line(s): $LINE_NUMS"
    echo "   → To review: git show :$FILE | sed -n '<LINE>p'"
    echo "Please remove this secret before committing."
    
    FOUND_SECRETS=1
  fi
done

if [ $FOUND_SECRETS -eq 1 ]; then
  echo ""
  echo "If this is a false positive, use 'git commit --no-verify' to bypass."
  exit 1
fi

echo "✅ Security check passed."
exit 0
